#include<stdio.h>
#include"Create.c"

#define ARRAYLWN   10


/*
	堆排序


  堆排序是对树排序的改进

  具体做法是：
  1）将待排序记录用一棵完全二叉树的顺序来表示，待排序记录还是采用数组来存储而不是采用树形存数结构
  2) 每个记录作为一个结点，a[0]作为二叉树的根，后面的各个记录依次逐层的从左到右排列
		如果下标从0开始
		任意结点a[i]的左孩子是a[2*i+1]，右孩子是a[2*i+2]，双亲是a[i/2-1]
		如果下标从1开始
		任意结点a[i]的左孩子是a[2*i]，右孩子是a[2*i+1]，双亲是a[i/2]
  3) 最后调整这棵完全二叉树，使各个结点的关键字满足下列条件（以下标为0举例）
		
		  a[i]>=a[2i+1]&&a[i]>=a[2i+2]

		将满足上述条件的完全二叉树称之为堆。将此堆中根节点的最大关键字称之为大根堆。反之
		如果此完全二叉树中的任意结点的关键字小于或等于左右孩子的关键字（如果有左右孩子的话）称之为小根堆


  堆排序的过程主要是解决如下几个过程：
  （1）如何重建堆
  （1）如何由一个任意序列建成初堆
  （3）如何利用堆进行排序



  使用堆排序的具体过程如下所示：
  （1）将任意一个序列建成初堆，并输出堆顶的元素的值
  （2）调整剩余的记录序列，使用筛选法将前面的n-i个记录重新筛选，以便于建成一个新堆并输出堆顶的额元素
  （3）重复执行不收（2），实现n-1次筛选，这样新筛选成的堆就会越来越小，而新堆后面的有序关键字就会越来越多，最后
		使得待排序记录序列成为一个有序的序列，这个过程就称之为堆排序


  直接选择排序在第i躺中总是会进行n-i次比较从而找到关键字最小的记录
  事实上，有可能这些比较前面已经做过很多次，但是由于前面的排序并没有记录排序的结果，所以后面的比较有执行了重复的操作
  堆排序就好似通过树形结构来保存部分比较过的结果，从而减少了比较的次数，优化了时间复杂度‘


  对于有n个记录的待排序序列，构成完全二叉树的
	
	  深度是 k = 以2为底n的对数
	  所以堆排序的时间复杂度为O(log(n*k))
	  而直接选择排序的空间复杂度为O(n^2)

		
*/

void sift(int a[],int m ,int n);
 
void sift(int a[],int m ,int n){

	int tem = 0; 
	int j = 0; 

	for(j = 2*m+1;j<n;j++){
		if((j+1)<n){// 如果右子树存在的话
			if(a[j]<a[j+1])//如果左子树小于右子树，则需要比较右子树
				j++;
		}
		if(a[m]<a[j]){//如果待待调整结点的值比a[j]小的话，则交换两个值的位置
			tem = a[m];
			a[m] = a[j];
			a[j] = tem;
			m = j;//发生交换了交换之后堆就会被破坏，所以要重新创建堆
		}
		else
			break;
	
	}

/*	while(2*m+1<n){
		j = 2*m+1;
		if((j+1)<n){
			if(a[j]<a[j+1])
				j++;
		}
		if(a[m]<a[j]){
			tem = a[m];
			a[m] = a[j];
			a[j] = tem;
			m = j;
		}
		else
			break;
	}	*/
}
void HeapSort(int a[],int n){

	int i = 0;
	int b= 0 ;

	//创建堆
	for(i = n/2-1;i>=0;i--)//将a[0,n-1]建成大根堆
		sift(a,i,n);
	printf("创建堆完成:");
	for(i = 0;i<ARRAYLWN;i++)
		printf("%d ",a[i]);
	printf("\n");
	// 堆排序
	for(i = n-1;i>0;i--){
		b = a[0];
		a[0] = a[i];
		a[i] = b;
		sift(a,0,i);//将a[0]至a[i]重新调整
	}	
}
int main(void){
		int i ;
		int a[ARRAYLWN] = {88,85,14,27,51,33,53,79,37,17};
		/*for(i = 0;i<ARRAYLWN;i++)
			a[i] = 0;
		if(!Create(a,ARRAYLWN,1,100)){
			printf("生成随机数失败！");
			getch();
			return 1;
		}*/
		printf("原数据:");
		for(i = 0;i<ARRAYLWN;i++){
			printf("%d ",a[i]);
		}
		printf("\n");
		HeapSort(a,ARRAYLWN);
		printf("排序后:");
		for(i = 0;i<ARRAYLWN;i++)
			printf("%d ",a[i]);
		printf("\n");
		getch();
		return 0;
	}