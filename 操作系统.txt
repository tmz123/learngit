一，进程与线程：
	1.1 进程与线程的概念：
		进程：具有独立功能的程序代码是关于数据集的一次运行活动。有程序有资源
		线程：是比进程更小的能独立运行的基本单位
		进程是系统进行资源分配和调度的一个独立单位
		注：线程是进程的一个实体，是CPU调度和分配的基本单位。
				线程自己基本不拥有系统资源，但是它可与同属于一个进程的其他的线程共享进程所有的全部资源
	1.2 进程与线程的区别
		(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;
		(2)资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
		(3)线程是处理器调度的基本单位,但进程不是.
	  (4)二者均可并发执行.
	1.3 进程的创建
		(1)给新进程分配一个唯一的进程标识符
		(2)给进程分配空间（申请空白的进程控制块PCB）
		(3)初始化PCB
		(4)将新的进程插入到就绪队列
	1.4 进程间的通讯（IPC）
		(1)（未命名）管道:只能用于父子进程通讯,管道是先进先出的通讯方式
		(2)命名管道(FIFO):任何进程间都能通讯，但速度慢
		(3)信号量:信号量是一个计数器，可以用来控制多个进程对共享资源的访问(进程同步手段)
		(4)消息队列:消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。
			消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点 
		(5)共享内存:共享内存就是映射一段能被其他进程所访问的内存，
			这段共享内存由一个进程创建，但多个进程都可以访问。
			共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的
		
			注：以上几种方式的比较：
					1.管道：速度慢，容量有限，只有父子进程能通讯
					2.FIFO：任何进程间都能通讯，但速度慢
					3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据
					4.信号量：不能传递复杂消息，只能用来同步
					5.共享内存区：能够很容易控制容量，速度快，但要保持同步
	1.5 线程间的通讯
		(1)锁机制：包括互斥锁、条件变量、读写锁
		   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
		   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
		   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
  	(2)信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
  	(3)信号机制(Signal)：类似进程间的信号处理
  	注：
    线程间的通信目的主要是用于线程同步，故线程没有像进程通信中的用于数据交换的通信机制。
  1.6 进程的几种状态？
  	创建，就绪（提交），运行（调度运行），阻塞（等待事件未发生），退出
二，死锁：
	2.1 死锁概念：两个或者两个以上的进程因为其中的每个进程都在等待其他进程做完某些事情而不能继续执行
			这样的情形就叫做死锁。
	2.2 产生死锁的四个必要条件：
			互斥条件：资源不能被共享，只能由一个进程使用。
			请求与保持条件：已经得到资源的进程可以再次申请新的资源。
			非剥夺条件：已经分配的资源不能从相应的进程中被强制地剥夺。
			循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
	2.3 死锁产生的原因：
			竞争资源引起进程死锁；
			可剥夺资源和不可剥夺资源
			竞争不可剥夺资源；
			竞争临时资源
	2.4 避免死锁的算法：银行家算法
	2.5 处理死锁的方法：
			死锁预防：一次性申请所需要的全部资源
			死锁避免：使用银行家算法判断操作是否是安全的
			死锁检测：死锁发生后进行检测
			死锁解除：强制收回资源
三，windows的内存管理方式：
		分页存储管理基本思想：
				用户程序的地址空间被划分成若干固定大小的区域，称为“页”，
				相应地，内存空间分成若干个物理块，页和块的大小相等。
				可将用户程序的任一页放在内存的任一块中，实现了离散分配。
		分段存储管理基本思想：
				将用户程序地址空间分成若干个大小不等的段，
				每段可以定义一组相对完整的逻辑信息。
				存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。
		段页式存储管理基本思想：
			分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，
			便于段的共享与保护，将分页与分段两种存储方式结合起来，
			就形成了段页式存储管理方式。在段页式存储管理系统中，
			作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，
			然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，
			主存的分配以页为单位。段页式系统中，作业的地址结构包含三部分的内容：
			
			段号      页号       页内位移量
			
			程序员按照分段系统的地址结构将地址分为段号与段内位移量，
			地址变换机构将段内位移量分解为页号和页内位移量。
			为实现段页式存储管理，系统应为每个进程设置一个段表，
			包括每段的段号，该段的页表始址和页表长度。
			每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。
	
四，虚拟内存与物理内存： 
		4.1 相关的概念
		物理内存：就是我们常说的内存条的容量。即地址线可以直接进行寻址的内存空间的大小
		虚拟内存：是计算机内存管理的一种抽象。当运行程序的时候需要的内存超过了物理内存的容量，
							那么就把程序的一核心部分放到物理内存中，而其它部分就放在外存（硬盘）中
							等到程序执行需要的时候再调度进入到物理内存中。
							换句话说，所谓的虚拟内存就是进程运行时所有内存空间的总和，
							并且可能有一部分不在物理内存中。
五，逻辑地址，物理地址，虚拟地址，线性地址，相对地址
		物理地址：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。页框号和偏移量
		虚拟地址：又称为逻辑地址，由页号和偏移量组成
		逻辑地址：程序产生的与段相关的偏移地址部分,
							由一个段标识符加上一个指定段内相对地址的偏移量。
		线性地址：逻辑地址到物理地址变换之间的中间层。
			注：在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。 
			　　如果没有启用分页机制，那么线性地址直接就是物理地址
			　　如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址：
			重定位指将一个操作数的逻辑地址转换为物理地址。
		
		虚拟地址到物理地址的转化：
		首先将给定一个逻辑地址（其实是段内偏移量），CPU利用其段式内存管理单元
		先将为个逻辑地址转换成一个线程地址，再利用其页式内存管理单元转换为最终物理地址。
		
		虚拟地址：分段允许程序员把内存看成多个地址空间或段组成，段的大小是不相等的，并且是动态的
		存储器访问以段号和偏移量的形式组成的地址
		
		 分页：产生内部碎片。缺点是要有相应的硬件支持
		 分段：产生小的外部碎片。按段为单位进行动态链接的代码共享
		 段页式：管理软件的增加，复杂性和开销就会增大的
		 
		 在段页式的系统中，用户端的空间被程序员划分成为许多段。每个段一次划分成
		 许多的固定大小的页，页的长度等于内存中的页框的大小。如果某一段的长度小于一页
		 则该段也会只占据一页。从程序员的角度看，逻辑地址仍然是由段号和段偏移量组成
		 从系统的角度看，段偏移量可以看作是指定段中的一个页号和页偏移量

			


